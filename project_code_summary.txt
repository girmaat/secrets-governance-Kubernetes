1. manifests/sealed-secrets/db-password-sealed.yaml

---
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  creationTimestamp: null
  name: db-password
  namespace: default
spec:
  encryptedData:
    password: AgCKNT0iSgz2/Q6W4hw+lejqtWoYbXEe8rkGDPJ63QqJfMIzobeWOXiDQJ98XqWnuUeVM91u/QgPOjog98TsHCiWc0QFsDsh+TgV3FHiMfEQRbaijQpE4Jj8i7ivzw8EbauoE1z61XWLzaNvdsWtxDHel3seKo3rpjuMdw6VLu9xesl/iOuBfwW6Su4sD9p78jEXGoERw9eOpgkjNlKA1V2Ix75LNYFOQApHeuOpL6UH42a1AoEOwJmiM5HC/D+KfpCbFJoneejtDLqB9nUpCnUBM/ruULCpD16Hkt2LswpTP5VY2Su+yHEw0goKfNH9YVZ2ySS8gbznCYVuZYfrXgqPU7wUT4++3YUjqvlTmTHFvDFCF1zokVZHNCupT8T8PcNodftIE86dxFm0+safDZqCVqISG1UMV9C87QpgbUlBG0Pb1a6M7PhwjSvZsycfIpL5SBW+gFzG4ARtLbHmRzk7JNEnkYHeYhpea0MIPYD+70eFqUJAZm5ZwwVnTqtK9x/9tHcGQd0nFy/uciFIQnlHIpWN7RiT5w8FUgk8XOe402hr/wYgpJEOLbiijuCTW1207T4cen+WrlgMgmYQYnF1r9+bq+uq5jCm2zQPGmG1WBKauCnASm2ShUQVMdRv9Muue1SI4HS18Ek/5WRq1oR6Z8iMX1+3QgPRkAvYgLRnoBG5js4du2Oh57sjxuBdPfH7QGosoMOu83Mx
  template:
    metadata:
      creationTimestamp: null
      name: db-password
      namespace: default



2. scripts/sealed-secrets/seal-secret.sh

#!/bin/bash

# --------------------------------------------
# Enhanced Sealed Secret Generator with Checks
# --------------------------------------------

set -euo pipefail

# Validate inputs
if [[ $# -lt 2 ]]; then
  echo "Usage: $0 <secret-name> <key>"
  echo "Example: $0 db-password password"
  exit 1
fi

SECRET_NAME=$1
KEY=$2
OUTPUT_PATH="manifests/sealed-secrets/${SECRET_NAME}-sealed.yaml"
CERT_PATH="pub-cert.pem"

# Check that the controller is installed and running
if ! kubectl get secret -n sealed-secrets -l sealedsecrets.bitnami.com/sealed-secrets-key >/dev/null 2>&1; then
  echo "âŒ Sealed Secrets key not found. Ensure the controller is installed and key is available."
  exit 1
fi

# Ensure the public cert exists
if [[ ! -f "$CERT_PATH" ]]; then
  echo "âŒ Error: $CERT_PATH not found. Export it from the controller before sealing."
  echo "Use:"
  echo "  kubectl get secret -n sealed-secrets -l sealedsecrets.bitnami.com/sealed-secrets-key \\"
  echo "    -o jsonpath='{.items[0].data[\"tls.crt\"]}' | base64 -d > pub-cert.pem"
  exit 1
fi

# Prompt user to enter the secret value
read -sp "ðŸ” Enter secret value for key '$KEY': " VALUE
echo

# Confirm where the output will go
echo "ðŸ“¦ Sealing and saving to: $OUTPUT_PATH"

# Ensure the output directory exists
mkdir -p "$(dirname "$OUTPUT_PATH")"

# Create and seal the secret
echo -n "$VALUE" | kubectl create secret generic "$SECRET_NAME" \
  --dry-run=client --from-literal="$KEY"=/dev/stdin -o json | \
  kubeseal --format yaml --cert "$CERT_PATH" > "$OUTPUT_PATH"

# Final output
echo "âœ… Sealed secret saved to: $OUTPUT_PATH"

# Post-sealing guidance
echo
echo "ðŸ“Œ Next steps:"
echo "  1. Review the sealed secret file:"
echo "     cat $OUTPUT_PATH"
echo "  2. Commit it to Git:"
echo "     git add $OUTPUT_PATH"
echo "     git commit -m 'Add sealed secret: $SECRET_NAME'"
echo "     git push origin <your-branch>"
echo "  3. Apply it to the cluster (if safe to do so):"
echo "     kubectl apply -f $OUTPUT_PATH"
echo
echo "ðŸ›  Troubleshooting tips:"
echo "  - Check controller logs:"
echo "      kubectl logs -n sealed-secrets -l app.kubernetes.io/name=sealed-secrets"
echo "  - Check for Secret creation or failure events:"
echo "      kubectl get events -n sealed-secrets"



3. scripts/sealed-secrets/verify-sealed-secrets-drift.sh

#!/bin/bash

# --------------------------------------------
# GitOps Drift Detection for Sealed Secrets
# --------------------------------------------

set -euo pipefail

SECRETS_DIR="manifests/sealed-secrets"
NAMESPACE="sealed-secrets"  # Adjusted as per your setup

echo "Checking for drift between Git and cluster (namespace: $NAMESPACE)"
echo

# Collect expected secret names from SealedSecret YAMLs
EXPECTED_SECRETS=()
for file in "$SECRETS_DIR"/*.yaml; do
  [[ -f "$file" ]] || continue
  SECRET_NAME=$(grep 'name:' "$file" | head -n 1 | awk '{print $2}')
  [[ -n "$SECRET_NAME" ]] && EXPECTED_SECRETS+=("$SECRET_NAME")
done

# Get actual Kubernetes secrets in the namespace
ACTUAL_SECRETS=$(kubectl get secrets -n "$NAMESPACE" -o jsonpath="{.items[*].metadata.name}")

# Convert to arrays
ACTUAL_ARRAY=($ACTUAL_SECRETS)

echo "SealedSecrets in Git but NOT in cluster:"
for expected in "${EXPECTED_SECRETS[@]}"; do
  if [[ ! " ${ACTUAL_ARRAY[*]} " =~ " ${expected} " ]]; then
    echo "$expected is missing from the cluster"
  fi
done

echo
echo "Secrets in cluster NOT tracked in Git:"
for actual in "${ACTUAL_ARRAY[@]}"; do
  if [[ ! -f "$SECRETS_DIR/${actual}-sealed.yaml" ]]; then
    echo "$actual exists in cluster but not in Git"
  fi
done

echo
echo "Drift check complete. Investigate or lines as needed."



4. scripts/sealed-secrets/verify-sealed-secrets.sh

#!/bin/bash

# ------------------------------
# Sealed Secrets Verification Tool
# ------------------------------

set -euo pipefail

SECRETS_DIR="manifests/sealed-secrets"
NAMESPACE="sealed-secrets" 

echo "Verifying sealed secrets in: $SECRETS_DIR"
echo "Target namespace: $NAMESPACE"
echo

for file in "$SECRETS_DIR"/*.yaml; do
  [[ -f "$file" ]] || continue  # skip if no files

  SECRET_NAME=$(grep 'name:' "$file" | head -n 1 | awk '{print $2}')
  if [[ -z "$SECRET_NAME" ]]; then
    echo "Could not extract secret name from $file"
    continue
  fi

  # Check if the actual Secret exists in the cluster
  if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" &>/dev/null; then
    # Optionally: check if the data field exists
    if [[ $(kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath="{.data}" | wc -c) -gt 5 ]]; then
      echo "$SECRET_NAME: Secret exists and contains data"
    else
      echo " $SECRET_NAME: Secret exists but has no data"
    fi
  else
    echo "$SECRET_NAME: Secret not found in namespace $NAMESPACE"
  fi
done

echo
echo "Verification complete. Review any or items above."



5. scripts/global/fix-aws-time-skew.sh

#!/bin/bash
set -euo pipefail

BLUE='\033[1;34m'
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

echo -e "${BLUE}ðŸ”§ Restarting chronyd...${NC}"
sudo systemctl restart chronyd

echo -e "${BLUE}â±ï¸ Forcing immediate time sync with 'chronyc makestep'...${NC}"
sudo chronyc makestep

echo -e "${BLUE}ðŸ” Checking new system time drift...${NC}"
chronyc tracking

echo -e "${BLUE}ðŸ” Verifying AWS credentials (sts get-caller-identity)...${NC}"
if aws sts get-caller-identity > /dev/null 2>&1; then
  echo -e "${GREEN}[âœ”] AWS credentials are now valid. Time is synced.${NC}"
else
  echo -e "${RED}[âœ˜] AWS authentication still failing. Check your credentials or session.${NC}"
  exit 1
fi


6. README.md

# About the project: Secure Secrets Delivery and Governance Platform for Kubernetes on AWS
This project is demo of an end-to-end DevSecOps architecture for managing secrets securely across CI/CD pipelines, GitOps deployments, and Kubernetes workloads running on AWS.

# Objectives
1. Secure secret storage, rotation, and delivery
2. Least-privilege access enforcement using IAM + KMS
3. Secrets observability using CloudTrail and Grafana
4. CI/CD secret scanning and policy enforcement
5. Git-safe secrets via Bitnami Sealed Secrets
6. Disaster recovery of sealed and runtime secrets


7. .gitignore

# === Terraform ===
*.tfstate
*.tfstate.backup
.terraform/
terraform.tfvars
.terraform.lock.hcl

# === Kubernetes Secrets / GitOps ===
*.crt              # TLS certs (Sealed Secrets, Ingress)
*.key              # TLS private keys
*.pem              # Public/private keys
*.enc              # Encrypted files
*.sealedsecret.yaml # Legacy sealed secret outputs
*.sealed.yaml       # Sealed Secrets outputs
manifests/sealed-secrets/*.yaml  # Optional: exclude committed secrets (adjust if needed)

# === AWS Secrets Manager ===
scripts/fetch-secrets-sm.py       # Optional: if dynamically generated
*.csv                             # Audit exports
*.audit.json                      # Output of scan scripts
*.secrets.json                    # Output from fetch scripts
.secrets/                         # Any cached or temp secrets

# === Logs / Outputs ===
*.log
*.out
*.err
*.tmp
tmp/

# === Python ===
__pycache__/
*.pyc
*.pyo
*.pyd
.env
.env.*

# === Node / JS (if applicable) ===
node_modules/
dist/
build/

# === IDE / Editor ===
.vscode/
.idea/
.DS_Store

# === CI / Audit Tools ===
.gitleaks-report.json
scan-results/
gitleaks-output/
conftest-report/

# === Backup Keys or Disaster Recovery ===
dr-tests/*.backup
dr-tests/*key*
dr-tests/sealed-secrets/*

# === Optional Custom Folders ===
test-output/
secrets-dumps/

.git


8. app-secrets-demo/Dockerfile

FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py .

EXPOSE 5000
CMD ["python", "app.py"]



9. app-secrets-demo/app.py

from flask import Flask, jsonify
import os

app = Flask(__name__)

@app.route("/")
def read_secret():
    secret = os.environ.get("APP_SECRET", "Not set")
    return jsonify({"secret": secret})

@app.route("/health")
def health():
    return "OK", 200

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)



10. app-secrets-demo/requirements.txt

Flask==2.3.2



11. app-secrets-demo/deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-secrets-demo
  labels:
    app: secrets-demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: secrets-demo
  template:
    metadata:
      labels:
        app: secrets-demo
    spec:
      serviceAccountName: irsa-secrets-demo  
      containers:
        - name: app
          image: app-secrets-demo:latest
          env:
            - name: APP_SECRET  # Reads value from sealed secret named app-secret
              valueFrom:
                secretKeyRef:
                  name: app-secret
                  key: secret-value

            - name: DB_PASSWORD  # Reads value from sealed secret named db-password
              valueFrom:
                secretKeyRef:
                  name: db-password
                  key: password

          ports:
            - containerPort: 5000



12. app-secrets-demo/service.yaml

apiVersion: v1
kind: Service
metadata:
  name: app-secrets-demo
spec:
  selector:
    app: secrets-demo
  ports:
    - protocol: TCP
      port: 80
      targetPort: 5000
  type: ClusterIP



13. app-secrets-demo/sealed-secret-template.yaml

apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: app-secret
  namespace: default
spec:
  encryptedData:
    secret-value: AgA4SD8...
  template:
    metadata:
      name: app-secret
      namespace: default
    type: Opaque



14. app-secrets-demo/README.md

# app-secrets-demo

A minimal Flask app that demonstrates secrets delivery via:

- ðŸ” Bitnami Sealed Secrets (sealed + decrypted at deploy time)
- ðŸ”‘ AWS Secrets Manager via IRSA (for dynamic access)
- ðŸ“Š CloudTrail & Grafana observability

## Endpoints

- `/` â€“ Returns the secret from environment or Kubernetes secret
- `/health` â€“ Simple liveness probe

## Setup

1. Seal a secret and apply:
    ```bash
    echo -n 'my-secret-token' | kubectl create secret generic app-secret --dry-run=client --from-literal=secret-value=... -o yaml | \
    kubeseal --cert pub-cert.pem --format yaml > sealed-secret-template.yaml
    ```

2. Apply manifests:
    ```bash
    kubectl apply -f sealed-secret-template.yaml
    kubectl apply -f deployment.yaml
    kubectl apply -f service.yaml
    ```

3. Port forward:
    ```bash
    kubectl port-forward svc/app-secrets-demo 8080:80
    ```

4. Test:
    ```bash
    curl http://localhost:8080/
    ```




15. pub-cert.pem

-----BEGIN CERTIFICATE-----
MIIEzDCCArSgAwIBAgIQYs2xI6ylmeqlnDP7sCwoAjANBgkqhkiG9w0BAQsFADAA
MB4XDTI1MDYwMzExMDQ1NloXDTM1MDYwMTExMDQ1NlowADCCAiIwDQYJKoZIhvcN
AQEBBQADggIPADCCAgoCggIBALSUZXkmBLPJDFuBM+kxyUrDqyC0HhEPUA93oJEE
V5TTAk09mVKHGJFqoefB/U6tQxiSA2Ph7ZOeLk+uUqbYFvFC3EPksTtYOTbl4KKM
DRxe6iisRK+9wp7uPgZf1n3RiQDkdzNgfM7VkELhNHcLyLCuCmSEED1FYMNM9W84
Uhq3ZbJyJ94DYs4BdAkJZKsfBhpN4MNDleBxWIkhFSmT7KY2Sd6W9vlWvH3HSA1Q
rWkWisSQdmis5+CtUHBxFT8p2BEfVA7N/u6B0K2K7krAiARpGyOMAnpr1ldTI236
pyzZPQ5H15cUNVcBXp5hfUxkIikdyUzyvYcQ9vxK7J2PTbWlXzLjykgWYp9AfB01
dl5v46QABN2L9gVJz4MGX67neccRstRQSBhNY3kgAur/cm68J84vcjPV5Xi256rQ
zH2EvZpMa4btnzsCZvo2sbMmxgMkbCV/YoMfnMzPCaOu/3BmSnIoK3oCm68agd6v
kdw6TiZwJn3hwnU0hz3O0rqSqD2hlDOWakCqmmCkFbTx+WIYcu9xhj+kfUefSeVA
CPkb0IoGPwkJtb7y8+lw4Ipcsv43Y3pgIUjsJXXOVHt+Ybhroy9gWa3TnAaFS8DZ
w8hwWcuVPdQmydqvMEG2pIrXKdXidKWuwGaQ4WCqWL7BZK7iBBVOTXckgbUJbDqO
YFLTAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIAATAPBgNVHRMBAf8EBTADAQH/MB0G
A1UdDgQWBBRMDrC26R3cBFux2mZY2kqlUBeFUDANBgkqhkiG9w0BAQsFAAOCAgEA
f9AkWkp34oHHpxaJET/TCfOwo/88JMX57xWgpiWJJBXIM+JhnteH8Fyy8Iz0weSd
Hx5oCJI555N4ZGF+M3/rgw9ouxZaVxqjMZWJ65X8kFzYU3qPD6yPJwhLx850g1zX
yCztxbrji9pElynB6DH+19DsNrgtg6CnDM43mffEml6jbo09ot3GfP88ecZG4PBj
DXKsFvRhqBYG17UTm563NPsHgKzj1264SAY5it0T5yZ6XvdJRtVj/G6JoGZEIq4v
ropB7aIdIpRCYcwwy9uGtQ0W12xmBGEIt2A8Qk0rAMcZqc6JCSOvm1+N3RPJztSl
vL4uKoou54aGYmJ08nEe2jFpDIZJRs5saAjagoTLWapdS0GuhsILifDqtjDMkaRq
Di6yDlhxZ7TaBWEJuPG83n4mvhL1VLtpP6ZNdf+Lend1ApIWtDR0q7Em979kzxjX
CHx8tdftpyyBQulYwGuIXoMAeknEI1bGH2PVWcJXXW9ZL5J0YTjDK6RRIetojOpS
fevWwEI8lgT6iYleI9+jZbU9rw1sZuzYdYiZMj3hY+qSFCrDFH3Ung57iBht7jj/
WrvuIZ0G8iPgqWENhlnq4JGgZyN53vuwMQsLkicttWetTrxY2QDrxUSMCNiO+vbC
cZS11Z5VfxpSUGX/AntJKj4KcpXY7gBXctokQWUwtvs=
-----END CERTIFICATE-----



